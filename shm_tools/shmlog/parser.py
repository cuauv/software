import struct
import shm
from shm import ShmEvalError
from datetime import datetime, timedelta
from time import time

'''
Log parsing framework for dealing with shared memory log files generated by the
shared memory logging daemon.

Jeff Heidel 2012
'''

#Dummy type representing the old string
#In this type, strings are read until the null character
#new strings involve integrated lengths
class OldStr:
    __name__ = "<OldString>"
old_str = OldStr()

GROUP = 0xFFFF
TIME = 0xFFFE

END_STBL = 0xFFFFFFFFFFFFFFFF

RS = chr(30)

MAGIC_NUMBER = b"AUVl";
type_lookup = {1: old_str, 2: int, 3: float, 4: str}

#some colored terminal printing
class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'

'''
Exception to be thrown when log parsing goes horribly wrong
'''
class LogParseException(Exception): pass

'''
Class for parsing raw log files into a useful format
'''
class LogParser:

    '''
    filename: Path to the log file
    verbose: optional flag for debug printing
    parse_file_end: option to disable parsing of the end_time and the snapshot table.
                    useful for log recovery. defaults to true.

    throws file IO exception if filename is invalid
    '''
    def __init__(self, filename, verbose=False, parse_file_end=True):
        self.verbose = verbose

        self.f = open(filename, 'rb', buffering=4096)

        first_line = self.f.readline()
        magic_num = first_line[:4]
        self.info = first_line[4:]

        self.warnings = []

        if magic_num != MAGIC_NUMBER:
            raise LogParseException("Given file was not an AUV shm log file")
            return

        #variable dictionary
        self.svars = {}

        #Parse file shared variable listing
        while True:
            x, = struct.unpack("=H", self.f.read(2))
            if x == GROUP: break #End of table 
            t, = struct.unpack("=c", self.f.read(1))
            s = self.__read_old_string()

            try:
                v = shm._eval(s)
            except ShmEvalError:
                self.warnings.append("WARNING: " + s + " does not match current shared memory")
                v = None
            
            typ = type_lookup[ord(t)]

            if not v is None:
                typv = type(v.get())
                if not typ == typv:
                    if not (set([typ, typv]) == set([str, old_str])):
                        v = None
                        self.warnings.append("WARNING: " + s + " is of type " + typv.__name__ + 
                               " in local shared memory, but type " + typ.__name__ + " in log")

            self.svars[x] = (v, s, typ)
            if verbose:
                print("read variable " + str(x) + " named " + s)
        if verbose:
            print("Done reading variables")
            print(str(len(self.svars)) + " variables read")
            print("Final dictionary:")
            print(str(self.svars))

        if len(self.warnings) > 0 and verbose:
            print('\n'.join(self.warnings))

        self.f.read(2) #Read past time flag which must exist

        curpos = self.f.tell() 
        
        #read the start time
        self.start_time = self.__read_time()

        self.end_time = self.start_time #temporary value

        self.snapshot_table = []

        #Only parse the end of file if desired
        #If the logfile is corrupt, we might not want to
        #This feature is used primarily for logfile recovery.
        if parse_file_end:

            self.f.seek(-16,2) #seek 16 bytes from the end

            #read out the snapshot table
            while True:
                snap_pos, = struct.unpack("=Q", self.f.read(8))
                snap_time = self.__read_time(); #read 8 bytes of time

                if snap_pos == END_STBL: #end of snapshot table
                    break

                #Check for incomplete logfile condition
                #Helpful hint: run auv-shmlog-rebuild to rebuild incomplete files
                def incomplete_except():
                    raise LogParseException("Logfile is incomplete.\nUse " + bcolors.FAIL + 
                            "auv-shmlog-rebuild [incomplete log] [new log]" + bcolors.ENDC + " to rebuild incomplete log files.")
                if snap_time < (self.start_time + timedelta(seconds=-10)):
                    incomplete_except()

                self.snapshot_table.append((snap_time,snap_pos))
                
                try:
                    self.f.seek(-32, 1)
                except IOError:
                    incomplete_except()
                     
            #read end time
            self.f.seek(-(16+8),1)
            self.end_time = self.__read_time()
            
        #return to proper file position for initial playback (first snapshot)
        self.f.seek(curpos)
                
        self.done = False

    #Clean up the file object nicely
    def __del__(self):
        self.f.close()

    '''
    Gets any warnings that occured during logparse init (i.e. variable doesn't match shared memory)
    Your program should pass these warnings to the user
    '''
    def get_warnings(self):
        return self.warnings

    '''
    Gets the time that this log started.
    '''
    def get_starttime(self):
        return self.start_time
 
    '''
    Gets the time that this log ended
    '''
    def get_endtime(self):
        return self.end_time

    '''
    Returns the number of items in the snapshot table
    Useful for seeking in the snapshot table by index
    '''
    def get_snapshot_count(self):
        return len(self.snapshot_table)
   
    '''
    Seeks to the closest preceeding snapshot in the file by default

    Set ahead to True to to seek to the closest succeeding snapshot
    Set prev to True to seek to the closest snapshot that precedes the given
    time by more than half a second

    Once this method is called, the next time slice read via parse_one_slice will contain every variable.
    '''
    def seek_nearest_snapshot(self, snap_time, ahead=False, prev=False):
        if snap_time > self.end_time or snap_time < self.start_time:
            raise LogParseException("Snapshot time was out of range!")

        snt, snp = self.snapshot_table[0]

        spacer = timedelta(0, 0)
        if prev:
            spacer = timedelta(0, 0.5)

        for snt_nxt, snp_nxt in self.snapshot_table:
            # timedelta added to snap_time is for unlikely case of selecting
            # a time in the middle of snapshot write
            if snt_nxt + spacer > snap_time + timedelta(0, 0.1):
                if ahead:
                    snp = snp_nxt
                break
            else:
                snt = snt_nxt
                snp = snp_nxt

        self.f.seek(snp + 2, 0) #seek to location + the time flag offset
        self.done = False

    '''
    Seeks to a specific snapshot index
    '''
    def seek_snapshot_index(self, index):

        if (index < 0 or index >= len(self.snapshot_table)):
            raise ValueError("Index out of allowed range")

        snt, snp = self.snapshot_table[index]
        self.f.seek(snp + 2, 0)
        self.done = False

    '''
    Parses one time slice of the log
        
        Return format is a nested list / tuple structure as follows:
            Return tuple of (slice's datetime, *list of variable changes*)
                *list of variable changes*: list containing tuples of the form
                    (shm variable instance [None if does not exist in current shared memory],
                     variable string [from log],
                     variable type [according to log],
                     new value)

        Returns None if log is finished parsing
    '''
    def parse_one_slice(self, benchmark=False, upgrade_file=None):
        if self.done:
            return None

        if benchmark:
            parse_start = time()
            type_times = {}
        
        vartime = self.__read_time(upgrade_file=upgrade_file) #Time of all of these variable changes
           
        if self.verbose:
            print("time is " + str(vartime))

        varchange = [] #Variables that have changed

        #Parse variable changes
        while True:
            if benchmark:
                var_start = time()

            tmp = self.f.read(2)
            x, = struct.unpack("=H", tmp)
            if upgrade_file is not None:
                upgrade_file.write(tmp)
            if x == GROUP: 
                self.done = True #End of log
                break 
            if x == TIME:
                break #Done with this time slice

            try:
                var, varstr, typ = self.svars[x]
            except KeyError:
                raise LogParseException("Log file corruption near " + str(hex(self.f.tell())))

            if typ == float:  #double
                tmp = self.f.read(8)
                val, = struct.unpack("=d", tmp)
                if upgrade_file is not None:
                    upgrade_file.write(tmp)
            elif typ == old_str: #old string, parse using old method
                val = self.__read_old_string()
            elif typ == str: #New string representation
                val = self.__read_string()
            else: #integer / bool
                tmp = self.f.read(4)
                val, = struct.unpack("=i", tmp)
                if upgrade_file is not None:
                    upgrade_file.write(tmp)

            if upgrade_file is not None and (typ == old_str or typ == str):
                #Manual write of a string
                upgrade_file.write(struct.pack("=L",len(val)))
                upgrade_file.write(val)
        
            varchange.append(self.svars[x] + (val,))
            if self.verbose:
                print("variable " + str(var) + " is " + str(val))

            if benchmark:
                var_diff = time() - var_start
                if typ not in type_times:
                    type_times[typ] = var_diff
                else:
                    type_times[typ] = type_times[typ] + var_diff

        if benchmark:
            parse_diff = time() - parse_start
            return (vartime, varchange, parse_diff, type_times)
         
        return (vartime, varchange)

    '''
    Returns True if there are no remaining time slices to be parsed.
    '''
    def finished_parsing(self):
        return self.done


    #Internal method: read a posix timestamp from the current location in the file
    def __read_time(self, upgrade_file=None):
        tmp = self.f.read(8)
        (sec, usec) = struct.unpack("=ll", tmp)
        if upgrade_file is not None:
            upgrade_file.write(tmp)
        psxtime = sec + usec/1e6
        return datetime.fromtimestamp(psxtime)

    #Internal method: read string from current location in the file
    #uses new method (length is specified before the word itself)
    def __read_string(self):
        strlen, = struct.unpack("=L", self.f.read(4))
        ret_str = self.f.read(strlen)
        return str(ret_str)

    #Internal method: read string from the current location in the file
    #Uses the old (slow) method of reading until the terminating character 
    def __read_old_string(self):
        y = self.f.read(1);
        s = ""
        while y.decode('latin-1') != RS:
            s += y.decode('latin-1')
            y = self.f.read(1)
        return str(s)
